#include <ChainableLED.h>
#include <TimerOne.h>
#include <RTClib.h>
#include "Seeed_BME280.h"
#include <Wire.h>
#include <SdFat.h>
#include <SPI.h>


//  Définition des pins
//  Initialisation des variables globales

//  énumération de nos modes = {CONFIG,STANDARD,MAINTENANCE,ECO}
//  Création de currentMode       //il récupère le mode actuel
//  Création de lastMode          //il récupère le mode précèdent

//prévisualisation des fonctions suivantes : 
  /*void changeMode(Mode newMode);
    void buttonPressed();
    void checkButton();
    void calculateDate(int* day, int* month, int* year);
    void saveDataToSD();
    void readAndPrintSensors();
    void ecoMode();
    void standardMode();
    void configMode();
    void maintenanceMode();
    void flashLedError(int red, int green, int blue, int duration1, int duration2);
    void checkError();
    void printDateTime();
*/

void setup(){
    // Initialiser Broches
    // Initialiser l'horloge RTC
    // vérifier l'état de l'horloge RTC
    // Initialiser les paramètres EEPROM
    // Initialiser les interruptions des boutons
    // Verifier si le bouton rouge est pressé
        // currentMode = CONFIG
    // Sinon currentMode = STANDARD   

}



void loop(){
  //  Appel de la fonction readAndPrintSensors()
  //  Appel de la fonction checkError()

  //  En cas de changement de mode :
  //  Si currentMode = CONFIG
    //  Appel de la fonction configMode()
  //  Sinon si currentMode = STANDARD
    //  Appel de la fonction standardMode()
  //  Sinon si currentMode = ECO
    //  Appel de la fonction ecoMode()
  //  Sinon si currentMode = MAINTENANCE
    //  Appel de la fonction maintenanceMode()


}

void checkError(){
  // initialiser errorFlag = false
  
  //  Si la carteSD n'est pas présente
    //  errorflag = true
    //  appel de la fonction flashLedError
  //  Si horloge RTC introuvable
    //  errorflag = true
    //  appel de la fonction flashLedError
  //  Si erreur de capteur de température,pression,hydrométrie
      //  errorflag = true
      //  appel de la fonction flashLedError
  //  Si température inconstante
      //  errorflag = true
      //  appel de la fonction flashLedError

  
  // Si errorFlag = false 
    // changer de mode
}


void printDateTime(){
  // récupère la date et l'heure du jour et l'écrit dans la l'interface série
}


void saveDataToSD(){
  //  récupérer le nom du fichier de sauvegarde
  //  Sauvegarde les données des capteurs sur la carte sd
 
  //  SI Erreur d’accès ou d’écriture sur la carte SD 
        //  LED intermittente rouge et blanche (fréquence 1Hz, durée 2 fois plus longue pour le blanc) à l'aide de flashLedError()
  //  SI Carte SD pleine 
        //  LED intermittente rouge et blanche (fréquence 1Hz, durée identique pour les 2 couleurs) à l'aide de flashLedError()
  //  Enregistre données sur carte SD jusqu'a ce que le fichier soit full (2ko), il ecrit sur un nouveau fichier
}

void flashLedError(int red, int green, int blue, int duration1, int duration2) {
  // Permettre  de faire clignoter la LED par intermitance
}


void readAndPrintSensors(){
  // appel des fonction de récupération des différents capteurs
  // écrit les données récupérées dans la console
}
int capteur_luminosite(){
    // vérifie l'état d'activation du capteur
    /* Récupérer niveau de luminosité : 
          Si Valeur < LUMIN_LOW -> renvoyer « faible » 
          Si Valeur > LUMIN_HIGH ->renvoyer « forte » 
          Si LUMIN_LOW<Valeur <LUMIN_HIGH ->renvoyer Valeur
    */
}

int sensorTemp(){
    // vérifie l'état d'activation du capteur
    /* Récupérer température: 
        Si Valeur < MIN_TEMP_AIR-> renvoyer une erreur
        Si Valeur > MAX_TEMP_AIR ->renvoyer une erreur
        Si MIN_TEMP_AIR <Valeur < MAX_TEMP_AIR ->renvoyer Valeur
    */
}

int sensorHydro(){
    // vérifie l'état d'activation du capteur
    /* Récupérer niveau d’hydrométrie: 
        Si Valeur < HYGR_MINT-> valeur pas prise en compte
        Si Valeur > HYGR_MAXT-> valeur pas prise en compte
        Si HYGR_MINT <Valeur < HYGR_MAXT ->renvoyer Valeur 
    */
}

int sensorPressure(){
    // vérifie l'état d'activation du capteur
    /* Récupérer niveau de pression: 
        Si Valeur < PRESSURE_MIN-> renvoyer une erreur
        Si Valeur > PRESSURE_MAX -> renvoyer une erreur
        Si PRESSURE_MIN <Valeur < PRESSURE_MAX ->renvoyer Valeur
    */
}

int sensorGps(){
    // vérifie l'état d'activation du capteur
    // Récupération position :
    // Si Erreur d’accès aux données du GPS
      //  LED intermittente rouge et jaune (fréquence 1Hz, durée identique pour les 2 couleurs)
    // Sinon retourne position GPS
}

void buttonPressed() {    //  vérifie quel bouton est préssé 
    //  Vérifie si le temps > 5000 ms 
    //  Vérifie l'état du mode
    //  appel fontion changeMode
}

void checkButton(){
  //  Vérifie si le temps de pression du boutonn est supérieur à 5 secondes
  //  Change de mode en fonction du bouton pressé
  //  Appel de la fonction changeMode('nom du prochaine mode')
}

void changeMode(Mode newMode) {  //  Fonction qui s'effectue lors d'un changement de mode

  //  si newMode = MAINTENANCE
    //  appel de la fonction maintenance en boucle
  //  sinon si newMode = ECO
    //  appel de la fonction economie en boucle
  //  sinon si newMode = STANDARD
    //  appel de la fonction standard en boucle
  //  sinon si newMode = CONFIG
    //  appel de la fonction configuration en boucle
}



void maintenanceMode(){
  //  Allumage led orange continue 
  //  Arrêt de la sauvegarde des données sur la carte SD
  //  Permettre de consulter les données en direct depuis le port série
  //  Permettre de changer la carte sd
}

void ecoMode(){
  //  Allumage led bleue continue 
  //  Temps entre l’acquisition données du GPS x2
  //  le temps entre 2 mesure (LOG_INTERVAL) x2
  //  Appel des fonctions des capteurs

}

void standardMode(){
  //  Allumage LED verte continue
  //  delay(LOG_INTERVAL)
  //  Appel des fonctions des capteurs
  //  Appel de la fonction sauvegarde_carteSD
  

}

void configMode(){
  //  Allumage LED jaune continue
  //  Permettre de taper des commandes de configuration pour modifier les valeurs des paramètres enregistrés dans l’EEPROM : 
    //  LOG_INTERVALL=10 -> définition de l’intervalle entre 2 mesures, 10 minutes par défaut. 
    //  FILE_MAX_SIZE=4096 -> définition de la taille maximale (en octets) d'un fichier de log, une taille de 4ko provoque son archivage. 
    //  RESET -> réinitialisation de l’ensemble des paramètres à leurs valeurs par défaut. 
    //  VERSION -> affiche la version du programme et un numéro de lot (permet de tracer la production) 
    //  Passer en mode standard au bout de 30 min 
}


void resetToDefaults(){
  //  initialisation de tous les paramètres aux valeurs par défaut
}

void calculateDate(){
  //  Récupère la date actuelle
  //  L'insère dans le pointeur qui correspond
}

